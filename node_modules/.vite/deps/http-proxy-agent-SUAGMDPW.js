import {
  Agent
} from "./chunk-IFY4K2PI.js";
import {
  require_events
} from "./chunk-Q6HK4PGV.js";
import {
  require_net,
  require_tls
} from "./chunk-L5GNONGA.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/ccxt/js/src/static_dependencies/proxies/http-proxy-agent/index.js
var net = __toESM(require_net(), 1);
var tls = __toESM(require_tls(), 1);
var import_events = __toESM(require_events(), 1);
function isHTTPS(protocol) {
  return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
}
var HttpProxyAgent = class extends Agent {
  constructor(proxy, opts) {
    super(opts);
    this.proxy = typeof proxy === "string" ? new URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.secureProxy ? 443 : 80;
    this.connectOpts = {
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  get secureProxy() {
    return isHTTPS(this.proxy.protocol);
  }
  async connect(req, opts) {
    const { proxy } = this;
    const protocol = opts.secureEndpoint ? "https:" : "http:";
    const hostname = req.getHeader("host") || "localhost";
    const base = `${protocol}//${hostname}`;
    const url = new URL(req.path, base);
    if (opts.port !== 80) {
      url.port = String(opts.port);
    }
    req.path = String(url);
    req._header = null;
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name of Object.keys(headers)) {
      const value = headers[name];
      if (value) {
        req.setHeader(name, value);
      }
    }
    let socket;
    if (this.secureProxy) {
      socket = tls.connect(this.connectOpts);
    } else {
      socket = net.connect(this.connectOpts);
    }
    let first;
    let endOfHeaders;
    req._implicitHeader();
    if (req.outputData && req.outputData.length > 0) {
      first = req.outputData[0].data;
      endOfHeaders = first.indexOf("\r\n\r\n") + 4;
      req.outputData[0].data = req._header + first.substring(endOfHeaders);
    }
    await (0, import_events.once)(socket, "connect");
    return socket;
  }
};
HttpProxyAgent.protocols = ["http", "https"];
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
export {
  HttpProxyAgent
};
//# sourceMappingURL=http-proxy-agent-SUAGMDPW.js.map
