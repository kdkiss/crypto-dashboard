{
  "version": 3,
  "sources": ["../../ccxt/js/src/static_dependencies/proxies/https-proxy-agent/index.js", "../../ccxt/js/src/static_dependencies/proxies/https-proxy-agent/parse-proxy-response.js"],
  "sourcesContent": ["// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport * as net from 'net';\nimport * as tls from 'tls';\nimport assert from 'assert';\nimport { Agent } from './../agent-base/index.js';\nimport { parseProxyResponse } from './parse-proxy-response.js';\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n */\nexport class HttpsProxyAgent extends Agent {\n    constructor(proxy, opts) {\n        super(opts);\n        this.options = { path: undefined };\n        this.proxy = typeof proxy === 'string' ? new URL(proxy) : proxy;\n        this.proxyHeaders = opts?.headers ?? {};\n        // debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);\n        // Trim off the brackets from IPv6 addresses\n        const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, '');\n        const port = this.proxy.port\n            ? parseInt(this.proxy.port, 10)\n            : this.secureProxy\n                ? 443\n                : 80;\n        this.connectOpts = {\n            // Attempt to negotiate http/1.1 for proxy servers that support http/2\n            ALPNProtocols: ['http/1.1'],\n            ...(opts ? omit(opts, 'headers') : null),\n            host,\n            port,\n        };\n    }\n    get secureProxy() {\n        return isHTTPS(this.proxy.protocol);\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     */\n    async connect(req, opts) {\n        const { proxy, secureProxy } = this;\n        if (!opts.host) {\n            throw new TypeError('No \"host\" provided');\n        }\n        // Create a socket connection to the proxy server.\n        let socket;\n        if (secureProxy) {\n            // debug('Creating `tls.Socket`: %o', this.connectOpts);\n            socket = tls.connect(this.connectOpts);\n        }\n        else {\n            // debug('Creating `net.Socket`: %o', this.connectOpts);\n            socket = net.connect(this.connectOpts);\n        }\n        const headers = typeof this.proxyHeaders === 'function'\n            ? this.proxyHeaders()\n            : { ...this.proxyHeaders };\n        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\n        // Inject the `Proxy-Authorization` header if necessary.\n        if (proxy.username || proxy.password) {\n            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\n            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;\n        }\n        headers.Host = `${host}:${opts.port}`;\n        if (!headers['Proxy-Connection']) {\n            headers['Proxy-Connection'] = this.keepAlive\n                ? 'Keep-Alive'\n                : 'close';\n        }\n        for (const name of Object.keys(headers)) {\n            payload += `${name}: ${headers[name]}\\r\\n`;\n        }\n        const proxyResponsePromise = parseProxyResponse(socket);\n        socket.write(`${payload}\\r\\n`);\n        const { connect, buffered } = await proxyResponsePromise;\n        req.emit('proxyConnect', connect);\n        // @ts-ignore\n        this.emit('proxyConnect', connect, req);\n        if (connect.statusCode === 200) {\n            req.once('socket', resume);\n            if (opts.secureEndpoint) {\n                // The proxy is connecting to a TLS server, so upgrade\n                // this socket connection to a TLS connection.\n                // debug('Upgrading socket connection to TLS');\n                const servername = opts.servername || opts.host;\n                return tls.connect({\n                    ...omit(opts, 'host', 'path', 'port'),\n                    socket,\n                    servername: net.isIP(servername) ? undefined : servername,\n                });\n            }\n            return socket;\n        }\n        // Some other status code that's not 200... need to re-play the HTTP\n        // header \"data\" events onto the socket once the HTTP machinery is\n        // attached so that the node core `http` can parse and handle the\n        // error status code.\n        // Close the original socket, and a new \"fake\" socket is returned\n        // instead, so that the proxy doesn't get the HTTP request\n        // written to it (which may contain `Authorization` headers or other\n        // sensitive data).\n        //\n        // See: https://hackerone.com/reports/541502\n        socket.destroy();\n        const fakeSocket = new net.Socket({ writable: false });\n        fakeSocket.readable = true;\n        // Need to wait for the \"socket\" event to re-play the \"data\" events.\n        req.once('socket', (s) => {\n            // debug('Replaying proxy buffer for failed request');\n            assert(s.listenerCount('data') > 0);\n            // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n            // this point the HTTP module machinery has been hooked up for\n            // the user.\n            s.push(buffered);\n            s.push(null);\n        });\n        return fakeSocket;\n    }\n}\nHttpsProxyAgent.protocols = ['http', 'https'];\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n", "// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nexport function parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('close', onclose);\n            socket.removeListener('readable', read);\n        }\n        function onclose(err) {\n            // debug('onclose had error %o', err);\n        }\n        function onend() {\n            // debug('onend');\n        }\n        function onerror(err) {\n            cleanup();\n            // debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                // debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const headerParts = buffered.toString('ascii').split('\\r\\n');\n            const firstLine = headerParts.shift();\n            if (!firstLine) {\n                throw new Error('No header received');\n            }\n            const firstLineParts = firstLine.split(' ');\n            const statusCode = +firstLineParts[1];\n            const statusText = firstLineParts.slice(2).join(' ');\n            const headers = {};\n            for (const header of headerParts) {\n                if (!header)\n                    continue;\n                const firstColon = header.indexOf(':');\n                if (firstColon === -1) {\n                    throw new Error(`Invalid header: \"${header}\"`);\n                }\n                const key = header.slice(0, firstColon).toLowerCase();\n                const value = header.slice(firstColon + 1).trimStart();\n                const current = headers[key];\n                if (typeof current === 'string') {\n                    headers[key] = [current, value];\n                }\n                else if (Array.isArray(current)) {\n                    current.push(value);\n                }\n                else {\n                    headers[key] = value;\n                }\n            }\n            // debug('got proxy server response: %o', firstLine);\n            cleanup();\n            resolve({\n                connect: {\n                    statusCode,\n                    statusText,\n                    headers,\n                },\n                buffered,\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('close', onclose);\n        socket.on('end', onend);\n        read();\n    });\n}\n"],
  "mappings": "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",
  "names": ["connect", "assert"]
}
